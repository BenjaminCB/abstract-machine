module Main where

import System.Directory (doesDirectoryExist, listDirectory)
import System.Environment (getArgs)
import System.FilePath ((</>))
import Data.Either (partitionEithers, either, isRight)

import AST qualified
import AbstractMachine qualified as AM
import Parser

-- autogenerated
getAllFilePaths :: FilePath -> IO [FilePath]
getAllFilePaths dir = do
    entries <- listDirectory dir
    paths <-
        mapM
            ( \entry -> do
                let fullPath = dir </> entry
                isDir <- doesDirectoryExist fullPath
                if isDir
                    then getAllFilePaths fullPath
                    else return [fullPath]
            )
            entries
    return (concat paths)

partition :: [(a, Either b c)] -> ([(a, b)], [(a, c)])
partition = foldr f ([], [])
  where
    f (a, e) (ls, rs) = either (\l -> ((a, l) : ls, rs)) (\r -> (ls, (a, r) : rs)) e

main :: IO ()
main = do
    [rootDir, entryPoint] <- getArgs
    paths <- getAllFilePaths rootDir
    fileContents <- mapM readFile paths
    let tuples = zip paths fileContents
    let parseResults = map (fmap parseInput) tuples
    let (errs, srcFiles) = partition parseResults
    mapM_ print errs
    mapM_ print srcFiles
