module Main where

import Data.Map qualified as M
import System.Directory (doesDirectoryExist, listDirectory)
import System.Environment (getArgs)
import System.FilePath ((</>))
import Data.Bifunctor (first)
import Control.Monad.State.Lazy

import Parser
import AbstractMachine qualified as AM

-- autogenerated
getAllFilePaths :: FilePath -> IO [FilePath]
getAllFilePaths dir = do
    entries <- listDirectory dir
    paths <-
        mapM
            ( \entry -> do
                let fullPath = dir </> entry
                isDir <- doesDirectoryExist fullPath
                if isDir
                    then getAllFilePaths fullPath
                    else return [fullPath]
            )
            entries
    return (concat paths)

partition :: [(a, Either b c)] -> ([(a, b)], [(a, c)])
partition = foldr f ([], [])
    where
        f (a, e) (ls, rs) = either (\l -> ((a, l) : ls, rs)) (\r -> (ls, (a, r) : rs)) e

main :: IO ()
main = do
    [rootDir, entryPoint] <- getArgs
    paths <- getAllFilePaths rootDir
    fileContents <- mapM readFile paths
    let tuples = zip paths fileContents
    let parseResults = map (fmap parseInput) tuples
    let (errs, srcFiles) = partition parseResults
    putStrLn "Parse Errors:"
    mapM_ print errs
    putStrLn ""
    putStrLn "Source files:"
    mapM_ print srcFiles
    putStrLn ""
    let fileGetter = M.fromList (map (first $ drop (length rootDir)) srcFiles)
    case M.lookup entryPoint fileGetter of
        Just src -> do
            let amResult = runStateT (AM.run [AM.SrcFile src] [] [entryPoint]) (fileGetter, M.empty, M.empty)
            case amResult of
                Left err -> do
                    putStrLn "AM Error:"
                    putStrLn err
                Right (_, (_, locals, _)) -> do
                    -- putStrLn "locals:"
                    print locals
        Nothing -> do
            putStrLn "Entry point not found"
