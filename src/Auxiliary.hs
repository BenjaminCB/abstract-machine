module Auxiliary where

import System.Directory (doesDirectoryExist, listDirectory)
import System.FilePath ((</>))
import AST
import RecursionSchemes

import Data.Map qualified as M

class LUB a where
    (\/) :: a -> a -> a

-- autogenerated
getAllFilePaths :: FilePath -> IO [FilePath]
getAllFilePaths dir = do
    entries <- listDirectory dir
    paths <-
        mapM
            ( \entry -> do
                let fullPath = dir </> entry
                isDir <- doesDirectoryExist fullPath
                if isDir
                    then getAllFilePaths fullPath
                    else return [fullPath]
            )
            entries
    return (concat paths)

partition :: [(a, Either b c)] -> ([(a, b)], [(a, c)])
partition = foldr f ([], [])
    where
        f (a, e) (ls, rs) = either (\l -> ((a, l) : ls, rs)) (\r -> (ls, (a, r) : rs)) e

appendAtEveryN :: Int -> a -> [[a]] -> [[a]]
appendAtEveryN n x = go n
    where
        go _ [] = []
        go 0 (xs : xxs) = (xs ++ [x]) : go n xxs
        go m (xs : xxs) = xs : go (m - 1) xxs

unsafeLookup :: Ord k => k -> M.Map k v -> v
unsafeLookup k m = case M.lookup k m of
  Just v -> v
  Nothing -> error "unsafeLookup: key not found"

-- | TODO should probably make a safe version of this
unpackSrcFile :: M.Map String (SrcFile String) -> String -> Term SrcFile
unpackSrcFile srcFiles name = In $ SrcFile is' ss es where
    SrcFile is ss es = unsafeLookup name srcFiles
    is' = map (fmap (unpackSrcFile srcFiles)) is
